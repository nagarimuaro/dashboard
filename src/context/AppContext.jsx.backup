import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { authService } from '../services/authService.js';
import { dashboardService } from '../services/dashboardService.js';
import apiClient from '../services/apiClient.js';

const AppContext = createContext();

export const useApp = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useApp must be used within AppProvider');
  }
  return context;
};

export const AppProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [tenant, setTenant] = useState(null);
  const [dashboardStats, setDashboardStats] = useState(null);
  const [notifications, setNotifications] = useState([]);
  const [loading, setLoading] = useState(true);
  const [initialized, setInitialized] = useState(false);

  // Initialize app on mount
  useEffect(() => {
    const initialize = async () => {
      try {
        setLoading(true);
        
        // Initialize auth from storage
        const { token, tenant: storedTenant } = authService.initializeAuth();
        
        if (storedTenant) {
          setTenant(storedTenant);
        }
        
        // Detect tenant from subdomain if not in storage
        if (!storedTenant) {
          const subdomain = window.location.hostname.split('.')[0];
          if (subdomain !== 'www' && subdomain !== 'localhost' && subdomain !== '127' && !subdomain.includes('figma')) {
            const detectedTenant = { slug: subdomain, nama: `Nagari ${subdomain.charAt(0).toUpperCase() + subdomain.slice(1)}` };
            setTenant(detectedTenant);
            apiClient.setTenant(subdomain);
            localStorage.setItem('current_tenant', JSON.stringify(detectedTenant));
          } else {
            // Default to Cilandak for localhost development
            const defaultTenant = { slug: 'cilandak', nama: 'Nagari Cilandak' };
            setTenant(defaultTenant);
            apiClient.setTenant('cilandak');
            localStorage.setItem('current_tenant', JSON.stringify(defaultTenant));
          }
        }
        
        // Get current user if token exists - with timeout protection
        if (token) {
          const storedUser = authService.getStoredUser();
          if (storedUser) {
            setUser(storedUser);
          }
          
          // Only try to fetch current user if we have a real token, not a mock one
          if (!token.startsWith('mock-jwt-token')) {
            try {
              // Add timeout protection for getCurrentUser
              const userPromise = authService.getCurrentUser();
              const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('User fetch timeout')), 5000)
              );
              
              const currentUser = await Promise.race([userPromise, timeoutPromise]);
              const userData = currentUser.data || currentUser;
              setUser(userData);
              localStorage.setItem('user_data', JSON.stringify(userData));
            } catch (error) {
              console.warn('Failed to fetch current user:', error.message);
              // For any error, keep the stored user data if available
              if (storedUser) {
                console.log('Using stored user data due to fetch error');
              } else {
                // No stored user and fetch failed, clear auth
                authService.logout();
              }
            }
          } else {
            console.log('Using stored user data for mock session');
          }
        }
      } catch (error) {
        console.error('App initialization error:', error);
      } finally {
        setLoading(false);
        setInitialized(true);
      }
    };

    // Add a small delay to prevent immediate timeouts
    const initTimer = setTimeout(initialize, 100);
    return () => clearTimeout(initTimer);
  }, []);

  // Load dashboard stats
  const loadDashboardStats = useCallback(async () => {
    if (!user) return;
    
    try {
      const stats = await dashboardService.getStats();
      setDashboardStats(stats);
    } catch (error) {
      console.error('Failed to load dashboard stats:', error);
    }
  }, [user]);

  // Login handler
  const login = useCallback(async (credentials) => {
    try {
      const response = await authService.login(credentials);
      
      // Handle both old and new response formats
      const userData = response.user || response.data?.user;
      const tenantData = response.tenant || response.data?.tenant;
      
      if (userData) {
        setUser(userData);
      }
      
      if (tenantData) {
        setTenant(tenantData);
      }
      
      return response.data || response;
    } catch (error) {
      throw error;
    }
  }, []);

  // Logout handler
  const logout = useCallback(async () => {
    try {
      await authService.logout();
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      setUser(null);
      setTenant(null);
      setDashboardStats(null);
      setNotifications([]);
    }
  }, []);

  // Switch tenant
  const switchTenant = useCallback((newTenant) => {
    setTenant(newTenant);
    apiClient.setTenant(newTenant.slug);
    localStorage.setItem('current_tenant', JSON.stringify(newTenant));
    
    // Clear dashboard stats as they're tenant-specific
    setDashboardStats(null);
    
    // Reload page to reset all state
    window.location.reload();
  }, []);

  // Add notification
  const addNotification = useCallback((notification) => {
    const newNotification = {
      id: Date.now(),
      timestamp: new Date(),
      read: false,
      ...notification
    };
    
    setNotifications(prev => [newNotification, ...prev]);
  }, []);

  // Mark notification as read
  const markNotificationRead = useCallback((id) => {
    setNotifications(prev => 
      prev.map(notif => 
        notif.id === id ? { ...notif, read: true } : notif
      )
    );
  }, []);

  // Clear all notifications
  const clearNotifications = useCallback(() => {
    setNotifications([]);
  }, []);

  // Get unread notification count
  const unreadCount = notifications.filter(n => !n.read).length;

  // Check if user has permission
  const hasPermission = useCallback((permission) => {
    if (!user) return false;
    
    // Super admin has all permissions
    if (user.role === 'admin_global') return true;
    
    // Define role-based permissions
    const permissions = {
      admin_nagari: [
        'manage_users',
        'manage_warga', 
        'manage_keluarga',
        'manage_pelayanan',
        'manage_templates',
        'manage_settings',
        'view_reports',
        'manage_arsip'
      ],
      staff_nagari: [
        'manage_warga',
        'manage_keluarga', 
        'manage_pelayanan',
        'view_reports'
      ],
      warga: [
        'create_permohonan',
        'view_my_permohonan'
      ]
    };
    
    const userPermissions = permissions[user.role] || [];
    return userPermissions.includes(permission);
  }, [user]);

  // Check if user can access module
  const canAccessModule = useCallback((module) => {
    if (!user) return false;
    
    const modulePermissions = {
      'dashboard': ['admin_global', 'admin_nagari', 'staff_nagari'],
      'data-warga': ['admin_global', 'admin_nagari', 'staff_nagari'],
      'data-keluarga': ['admin_global', 'admin_nagari', 'staff_nagari'],
      'permohonan-surat': ['admin_global', 'admin_nagari', 'staff_nagari', 'warga'],
      'kelola-permohonan': ['admin_global', 'admin_nagari', 'staff_nagari'],
      'template-manager': ['admin_global', 'admin_nagari'],
      'user-management': ['admin_global', 'admin_nagari'],
      'settings': ['admin_global', 'admin_nagari']
    };
    
    const allowedRoles = modulePermissions[module] || [];
    return allowedRoles.includes(user.role);
  }, [user]);

  const value = {
    // State
    user,
    tenant,
    dashboardStats,
    notifications,
    loading,
    initialized,
    unreadCount,
    
    // Actions
    login,
    logout,
    switchTenant,
    loadDashboardStats,
    addNotification,
    markNotificationRead,
    clearNotifications,
    
    // Utilities
    hasPermission,
    canAccessModule
  };

  return (
    <AppContext.Provider value={value}>
      {children}
    </AppContext.Provider>
  );
};